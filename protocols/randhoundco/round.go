// This file contains all the code to run one execution of a JVSS-based CoSi
// protocol. It outputs a signature which can be verified against the aggregated
// longterm public keys of all JVSS groups involved.
package randhoundco

import (
	"bytes"
	"errors"

	cosip "github.com/dedis/cosi/protocol"
	"github.com/dedis/cothority/log"
	"github.com/dedis/cothority/protocols/jvss"
	"github.com/dedis/cothority/sda"
	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/poly"
)

const ProtoName = "RandhounCo"

// roundClient runs a round of JVSS-based CoSi from the client point of view. It
// does not hold any JVSS protocol instance but launch and manage the JVSS-based
// cosi protocol.
type roundClient struct {
	*sda.TreeNodeInstance
	// the underlying cosi protocol
	cosi *cosip.CoSi
	// the message to sign used by the client role.
	msg []byte
	// the aggregate longterm distributed public key of all JVSS groups
	aggJVSSLongterm abstract.Point
	// the aggregate shortterm random distributed public key of all JVSS groups
	aggCommit abstract.Point
	// reference to the signature generated
	signature []byte
	// function to call when the signature is ready
	signatureHook SignatureHook
}

// roundLeader runs a round of a JVSS-based CoSi for a leader of a JVSS groups.
type roundLeader struct {
	*sda.TreeNodeInstance
	// the underlying cosi protocol
	cosi *cosip.CoSi
	// the sid of the short term secret generated for this group
	sid jvss.SID
	// the channel used to dispatch it to the next phase
	secretID chan jvss.SID
	// the challenge generated during the challenge phase
	challenge abstract.Scalar
	// the channel to give the signature generated by the JVSS group
	sigDone chan *poly.SchnorrSig
	// the JVSS protocol used for the group the leader is responsible for
	jvss *jvss.JVSS
}

// NewRoundRoot returns a protocol instance which is used by the root of
// the tree. It takes a message to be signed by this round, and the aggregated
// distributed public key of all JVSS groups.
func NewRoundClient(n *sda.TreeNodeInstance, msg []byte, aggJVSSLongterm abstract.Point) (sda.ProtocolInstance, error) {
	p, err := cosip.NewCoSi(n)
	if err != nil {
		return nil, err
	}
	cosi := p.(*cosip.CoSi)
	go cosi.Dispatch()

	rc := &roundClient{
		TreeNodeInstance: n,
		cosi:             cosi,
		msg:              msg,
		aggJVSSLongterm:  aggJVSSLongterm,
	}
	rc.cosi.RegisterCommitmentHook(rc.onCommitment)
	rc.cosi.RegisterResponseHook(rc.onResponse)
	return rc, nil
}

// NewRandhoundCoNode returns a protocol which designates a leader of a JVSS // group in the big Randhound tree - intermediate node -
func NewRoundLeader(n *sda.TreeNodeInstance, jvssP *jvss.JVSS) (sda.ProtocolInstance, error) {
	p, err := cosip.NewCoSi(n)
	if err != nil {
		return nil, err
	}
	go p.Dispatch()
	cosi := p.(*cosip.CoSi)
	rc := &roundLeader{
		TreeNodeInstance: n,
		jvss:             jvssP,
		cosi:             cosi,
		secretID:         make(chan jvss.SID),
		sigDone:          make(chan *poly.SchnorrSig),
	}

	rc.cosi.RegisterAnnouncementHook(rc.onAnnouncement)
	rc.cosi.RegisterCommitmentHook(rc.onCommitment)
	rc.cosi.RegisterChallengeHook(rc.onChallenge)
	rc.cosi.RegisterResponseHook(rc.onResponse)
	return rc, nil
}

// Start is called by the client to launch a new round. It will pass down an
// Announcement message down the tree.
func (r *roundClient) Start() error {
	out := &cosip.Announcement{}
	return r.SendToChildren(out)
}

func (r *roundLeader) Start() error {
	return errors.New("I should be put in this position,too much")
}

// onAnnouncement launches the short term distributed secret generation within
// the JVSS group of this leader
func (r *roundLeader) onAnnouncement(in *cosip.Announcement) error {
	go func() {
		log.Lvl2(r.Name(), "lauch jvss.SignPrepare()")
		sid, err := r.jvss.SignPrepare()
		if err != nil {
			log.Error(err)
			sid = ""
		}
		r.secretID <- sid
	}()

	// start the commit phase
	if r.IsLeaf() {
		return r.onCommitment([]abstract.Point{})
	}

	// let the announcement going down
	return r.SendToChildren(in)
}

func (r *roundClient) onCommitment(commits []abstract.Point) error {
	return r.startChallenge(commits)
}

// onCommitments collects the short term secret commitment and pass it along
// with the others.
func (r *roundLeader) onCommitment(commits []abstract.Point) error {
	// get the random secret
	sid := <-r.secretID
	log.Lvl2(r.Name(), "Got the JVSS Secret")
	r.sid = sid
	secret, err := r.jvss.SharedSecret(sid)
	if err != nil {
		return err
	}

	// get the jvss commit
	commit := secret.Pub.SecretCommit()
	commits = append(commits, commit)
	aggCommit := r.Suite().Point().Null()
	for _, c := range commits {
		aggCommit.Add(aggCommit, c)
	}

	comMessage := &cosip.Commitment{aggCommit}
	return r.SendToParent(comMessage)
}

// startChallenge create a weirdly formatted message containing all informations
// to create the *real* challenge. It sends that special message down.
func (r *roundClient) startChallenge(commits []abstract.Point) error {
	aggCommit := r.Suite().Point().Null()
	for _, c := range commits {
		aggCommit.Add(aggCommit, c)
	}
	r.aggCommit = aggCommit
	// H( AggCommit || AggPublic || M)
	hash := r.Suite().Hash()
	if _, err := aggCommit.MarshalTo(hash); err != nil {
		return err
	}
	if _, err := r.aggJVSSLongterm.MarshalTo(hash); err != nil {
		return err
	}
	hash.Write(r.msg)
	challenge := r.Suite().Scalar().SetBytes(hash.Sum(nil))
	packet := &cosip.Challenge{challenge}
	log.Print(r.Name(), "Created challenge ", challenge)
	return r.SendToChildren(packet)
}

// store the challenge, launch the JVSS signature on it and sends it down the tree
func (r *roundLeader) onChallenge(challenge abstract.Scalar) error {
	msg, err := challenge.MarshalBinary()
	if err != nil {
		return err
	}
	// start the signing phase of JVSS
	go func() {
		log.Lvl2(r.Name(), "Lauching jvss.SignComplete()")
		sig, err := r.jvss.SignComplete(r.sid, msg)
		log.Print(r.Name(), "Lauching jvss.SignComplete() DONE", err)
		if err != nil {
			log.Error(err)
			sig = nil
		}
		r.sigDone <- sig
	}()

	if r.IsLeaf() {
		r.onResponse([]abstract.Scalar{})
		return nil
	}

	return r.SendToChildren(&cosip.Challenge{challenge})
}

// wait on the JVSS signature, collect children's responses and then pass up.
func (r *roundLeader) onResponse(resps []abstract.Scalar) {
	defer func() {
		r.cosi.Done()
		log.Print(r.Name(), "Calling Done()")
	}()
	// get the jvss signature
	log.Lvl2(r.Name(), "Waiting on the signature")
	sig := <-r.sigDone
	log.Lvl2(r.Name(), "Waiting on the signature DONE")
	if sig == nil {
		log.Error("No JVSS signature generated onResponse")
		return
	}

	// aggregate the responses
	resps = append(resps, *sig.Signature)
	agg := r.Suite().Scalar()
	for _, r := range resps {
		agg.Add(agg, r)
	}

	err := r.SendToParent(&cosip.Response{agg})
	if err != nil {
		log.Error(err)
	}
}

// onResponse computes the aggregation of the children's response, and then
// the signature as a slice of byte equal to:
// AggCommit || AggResponse
// Such  signature can be verified using `VerifySignature`.
// The signatureHook is called if one has been registered.
func (r *roundClient) onResponse(resps []abstract.Scalar) {
	log.Lvl2(r.Name(), "Client: on response -> final step")
	defer func() {
		r.cosi.Done()
		log.Print(r.Name(), "Calling Done()")
	}()
	// aggregate the responses
	aggResponse := r.Suite().Scalar()
	for _, r := range resps {
		aggResponse.Add(aggResponse, r)
	}
	buff := new(bytes.Buffer)
	if _, err := r.aggCommit.MarshalTo(buff); err != nil {
		log.Error(err)
		return
	}
	if _, err := aggResponse.MarshalTo(buff); err != nil {
		log.Error(err)
		return
	}
	r.signature = buff.Bytes()
	if r.signatureHook != nil {
		r.signatureHook(r.signature)
	}
}

// SignatureHook is the type of the function that is called when a randhoundco
// signature has been generated.
type SignatureHook func(sig []byte)

// RegisterOnSignature takes a SignatureHook and stores it. This function will
// be called when the signature is generated for a round.
func (r *roundClient) RegisterOnSignature(fn SignatureHook) {
	r.signatureHook = fn
}

// VerifySignature returns nil if the signature issued for a round of
// randhoundco is valid or an error otherwise. aggPublic is the Aggregate
// Longterm Distributed Public Keys of ALL JVSS groups.
func VerifySignature(suite abstract.Suite, aggPublic abstract.Point, msg, sig []byte) error {
	buffer := bytes.NewBuffer(sig)
	aggCommit := suite.Point()
	if _, err := aggCommit.UnmarshalFrom(buffer); err != nil {
		return err
	}

	aggResponse := suite.Scalar()
	if _, err := aggResponse.UnmarshalFrom(buffer); err != nil {
		return err
	}

	// left: g^r
	left := suite.Point().Mul(nil, aggResponse)

	// right: aggCommit + challenge * aggPublic
	// challenge: H(aggCommit || aggPublic || msg)
	hash := suite.Hash()
	if _, err := aggCommit.MarshalTo(hash); err != nil {
		return err
	}
	if _, err := aggPublic.MarshalTo(hash); err != nil {
		return err
	}
	hash.Write(msg)
	challenge := suite.Scalar().SetBytes(hash.Sum(nil))

	right := suite.Point().Mul(aggPublic, challenge)
	right = right.Add(right, aggCommit)

	if !right.Equal(left) {
		return errors.New("Signature re-created are not equal")
	}
	return nil
}
