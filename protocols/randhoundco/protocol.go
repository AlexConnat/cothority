// This file contains all the code to SETUP (setup.go) a randhoundco system and launch
// rounds of JVSS-based CoSi protocol (round.go).
package randhoundco

import (
	"errors"
	"sync"

	cosip "github.com/dedis/cosi/protocol"
	"github.com/dedis/cothority/log"
	"github.com/dedis/cothority/protocols/jvss"
	"github.com/dedis/cothority/sda"
)

type protoClient struct {
	*sda.TreeNodeInstance

	// the setup protocol
	setup *setupClient
	// the groups generated by the setup
	grStore *groupsStore
	// forces the protocol to accept only one round at a time
	roundMut sync.Mutex

	// controls whether this protocol should finish or not
	*onDone
}

type protoLeader struct {
	*sda.TreeNodeInstance

	// setupLeader that reacted to the setup of the system from the client
	*setupLeader
	// the jvss protocol instantiated by the setup protocol
	jvProto *jvss.JVSS
	jvMut   *sync.Cond

	// HACK: this cosi protocol catches all cosi related messages. On
	// announcement, protoLeader will create the roundLeader. This roundLeader
	// creates a CoSi protocol which will overwrite the different messages of
	// the cosi protocol it can run fine.
	catch *cosip.CoSi

	// controls whether this protocol should finish or not
	*onDone
}

func NewClientProtocol(n *sda.TreeNodeInstance, groups GroupRequests) (*protoClient, error) {
	setup, err := NewSetupClient(n, groups)
	if err != nil {
		return nil, err
	}
	pc := &protoClient{
		TreeNodeInstance: n,
		setup:            setup,
		grStore:          newGroupsStore(),
		onDone:           &onDone{},
	}
	setup.RegisterOnSetupDone(func(g *Groups) {
		pc.grStore.store(g)
		// broadcast the groups to all the leaders
		if err := pc.SendToChildren(g); err != nil {
			log.Error(err)
		}
	})
	// don't release the our TreeNodeInstance.
	pc.OnDoneCallback(pc.onDoneCB)

	return pc, nil
}

func NewLeaderProtocol(n *sda.TreeNodeInstance) (*protoLeader, error) {
	// Need to register setup protocol here because it will receive the firsts
	// messages.
	setup, err := NewSetupLeader(n)
	pl := &protoLeader{
		TreeNodeInstance: n,
		setupLeader:      setup,
		jvMut:            sync.NewCond(&sync.Mutex{}),
		onDone:           &onDone{},
	}
	pl.RegisterOnJVSS(func(jv *jvss.JVSS) {
		pl.jvMut.L.Lock()
		pl.jvProto = jv
		pl.jvMut.L.Unlock()
		pl.jvMut.Signal()
	})
	// don't release our TreeNodeInstance
	pl.OnDoneCallback(pl.onDoneCB)
	// handler for receiving group request
	pl.RegisterHandler(pl.onGroups)
	// cosi catcher
	p, err := cosip.NewCoSi(n)
	if err != nil {
		return nil, err
	}

	pl.catch = p.(*cosip.CoSi)
	// catch announcements
	pl.catch.RegisterAnnouncementHook(pl.onCoSiAnnouncement)

	return pl, err
}

// Start the system setup protocol.
func (cp *protoClient) Start() error {
	return cp.setup.Start()
}

// Start does nothing in the case of a Leader since it should start any
// protocol.
func (cp *protoLeader) Start() error {
	return errors.New("I should not be in this position..")
}

// Groups wait the grouping generation from the setup protocol to finish and
// returns it.
func (cp *protoClient) Groups() *Groups {
	return cp.grStore.get()
}

// NewRound starts a new round of the jvss-based CoSi round and returns the
// resulting signature once it's ready.
func (cp *protoClient) NewRound(msg []byte) (sig []byte, err error) {
	cp.roundMut.Lock()
	defer cp.roundMut.Unlock()
	groups := cp.Groups()
	p, err := NewRoundClient(cp.TreeNodeInstance, msg, groups.Aggregate)
	if err != nil {
		return
	}
	round := p.(*roundClient)

	sigCh := make(chan []byte)
	round.RegisterOnSignature(func(roundSig []byte) {
		sigCh <- roundSig
	})

	go round.Start()
	return <-sigCh, nil
}

func (cp *protoLeader) onGroups(wg wrapGroups) error {
	// XXX not needed for the moment - later when CoSi-sign the whole structure
	// of groups.
	//cp.grStore.store(wg.Groups)
	return cp.SendToChildren(wg.Groups)
}

// onCoSiAnnouncement is a HACK in order to create the round protocol with the
// JVSS protocol instance. This announcement will be dispatched to the round
// protocol.
func (cp *protoLeader) onCoSiAnnouncement(in *cosip.Announcement) error {
	cp.jvMut.L.Lock()
	for cp.jvProto == nil {
		cp.jvMut.Wait()
	}
	defer cp.jvMut.L.Unlock()
	p, err := NewRoundLeader(cp.TreeNodeInstance, cp.jvProto)
	if err != nil {
		return err
	}

	round := p.(*roundLeader)
	return round.onAnnouncement(in)
}

// onDone keeps track of whether it has beek asked to close or only
// sub-protocols have closed.
type onDone struct {
	sync.Mutex
	done bool
}

func (o *onDone) onDoneCB() bool {
	o.Lock()
	defer o.Unlock()
	return o.done
}

func (o *onDone) setDone() {
	o.Lock()
	defer o.Unlock()
	o.done = true
}

// groupsStore is a thread safe way to wait for hte storage of one Groups
// struct.
type groupsStore struct {
	*sync.Cond
	g *Groups
}

func newGroupsStore() *groupsStore {
	return &groupsStore{
		Cond: sync.NewCond(&sync.Mutex{}),
	}
}

func (gs *groupsStore) store(g *Groups) {
	gs.L.Lock()
	gs.g = g
	gs.L.Unlock()
	gs.Broadcast()
}

func (gs *groupsStore) get() *Groups {
	gs.L.Lock()
	for gs.g == nil {
		gs.Wait()
	}
	defer gs.L.Unlock()
	return gs.g
}
