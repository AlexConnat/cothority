package proto

import (
	"bytes"
	"errors"

	cosip "github.com/dedis/cosi/protocol"
	"github.com/dedis/cothority/log"
	"github.com/dedis/cothority/protocols/jvss"
	"github.com/dedis/cothority/sda"
	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/poly"
)

const ProtoName = "RandhounCo"

// randhoundCo holds all informations to run a round of a JVSS-based CoSi.
// Basically, each node on the tree, except the root, represents a JVSS group
// with other
type randhoundCo struct {
	*sda.TreeNodeInstance
	// the underlying cosi protocol
	cosi *cosip.CoSi
	// either this protocol is started by a client or is an intermediate node
	// responsible of a JVSS group - leader -
	role string
	// the message to sign used by the client role.
	msg []byte
	// the aggregate longterm distributed public key of all JVSS groups
	aggJVSSLongterm abstract.Point
	// the aggregate shortterm random distributed public key of all JVSS groups
	aggCommit abstract.Point
	// the sid of the short term secret generated for this group
	sid jvss.SID
	// the channel used to dispatch it to the next phase
	secretID chan jvss.SID
	// the challenge generated during the challenge phase
	challenge abstract.Scalar
	// the channel to give the signature generated by the JVSS group
	sigDone chan *poly.SchnorrSig
	// reference to the signature generated
	signature []byte
	// function to call when the signature is ready
	signatureHook SignatureHook

	// the JVSS protocol used for the group the leader is responsible for
	jvss *jvss.JVSS
}

const (
	client = "client"
	leader = "leader"
)

// NewRandhoundCoRoot returns a protocol instance which is used by the root of
// the tree. It takes a message to be signed by this round, and the aggregated
// distributed public key of all JVSS groups.
func NewRandhoundCoRoot(n *sda.TreeNodeInstance, msg []byte, aggJVSSLongterm abstract.Point) (sda.ProtocolInstance, error) {
	p, _ := NewRandhoundCoNode(n, nil)
	rc := p.(*randhoundCo)
	rc.role = client
	rc.aggJVSSLongterm = aggJVSSLongterm
	rc.msg = msg
	return rc, nil
}

// NewRandhoundCoNode returns a protocol which designates a leader of a JVSS // group in the big Randhound tree - intermediate node -
func NewRandhoundCoNode(n *sda.TreeNodeInstance, jvssP *jvss.JVSS) (sda.ProtocolInstance, error) {
	p, err := cosip.NewCoSi(n)
	if err != nil {
		return nil, err
	}
	cosi := p.(*cosip.CoSi)
	rc := &randhoundCo{
		TreeNodeInstance: n,
		role:             leader,
		jvss:             jvssP,
		cosi:             cosi,
		secretID:         make(chan jvss.SID),
	}

	rc.cosi.RegisterAnnouncementHook(rc.onAnnouncement)
	rc.cosi.RegisterCommitmentHook(rc.onCommitment)
	rc.RegisterHandler(rc.onChallenge)
	rc.cosi.RegisterResponseHook(rc.onResponse)
	return rc, nil
}

// Start is called by the client to launch a new round. It will pass down an
// Announcement message down the tree.
func (r *randhoundCo) Start() error {
	out := &cosip.Announcement{}
	return r.SendToChildren(out)
}

// onAnnouncement launches the short term distributed secret generation within
// the JVSS group of this leader
func (r *randhoundCo) onAnnouncement() error {
	if r.role == client {
		return errors.New("onAnnouncement should not come as a client")
	}

	go func() {
		sid, err := r.jvss.SignPrepare()
		if err != nil {
			log.Error(err)
			sid = ""
		}
		r.secretID <- sid
	}()

	// start the commit phase
	if r.IsLeaf() {
		return r.onCommitment([]abstract.Point{})
	}

	// let the announcement going down
	out := &cosip.Announcement{}
	return r.SendToChildren(out)
}

// onCommitments collects the short term secret commitment and pass it along
// with the others.
func (r *randhoundCo) onCommitment(commits []abstract.Point) error {
	// get the random secret
	sid := <-r.secretID
	r.sid = sid
	secret, err := r.jvss.SharedSecret(sid)
	if err != nil {
		return err
	}

	// get the jvss commit
	commit := secret.Pub.SecretCommit()
	commits = append(commits, commit)
	// XXX careful when dealing with other suite / primitives...
	aggCommit := r.Suite().Point().Null()
	for _, c := range commits {
		aggCommit.Add(aggCommit, c)
	}

	if r.role == client {
		return r.startChallenge(aggCommit)
	}

	comMessage := &cosip.Commitment{aggCommit}
	return r.SendToParent(comMessage)
}

// startChallenge create a weirdly formatted message containing all informations
// to create the *real* challenge. It sends that special message down.
func (r *randhoundCo) startChallenge(aggCommit abstract.Point) error {
	if r.role != client {
		panic("Should not be here")
	}
	r.aggCommit = aggCommit
	// H( AggCommit || AggPublic || M)
	hash := r.Suite().Hash()
	if _, err := aggCommit.MarshalTo(hash); err != nil {
		return err
	}
	if _, err := r.aggJVSSLongterm.MarshalTo(hash); err != nil {
		return err
	}
	hash.Write(r.msg)
	challenge := r.Suite().Scalar().SetBytes(hash.Sum(nil))
	packet := &cosip.Challenge{challenge}
	return r.SendToChildren(packet)
}

// store the challenge, launch the JVSS signature on it and sends it down the tree
func (r *randhoundCo) onChallenge(challenge abstract.Scalar) error {
	if r.role == client {
		panic("should not be here")
	}
	msg, err := challenge.MarshalBinary()
	if err != nil {
		return err
	}
	// start the signing phase of JVSS
	go func() {
		sig, err := r.jvss.SignComplete(r.sid, msg)
		if err != nil {
			log.Error(err)
			sig = nil
		}
		r.sigDone <- sig
	}()

	if r.IsLeaf() {
		r.onResponse([]abstract.Scalar{})
		return nil
	}

	return r.SendToChildren(&cosip.Challenge{challenge})
}

func (r *randhoundCo) onResponse(resps []abstract.Scalar) {
	// get the jvss signature
	sig := <-r.sigDone
	if sig == nil {
		log.Error("No JVSS signature generated onResponse")
		return
	}

	// aggregate the responses
	resps = append(resps, *sig.Signature)
	agg := r.Suite().Scalar()
	for _, r := range resps {
		agg.Add(agg, r)
	}

	defer r.Done()

	if r.IsRoot() {
		r.sig(agg)
		return
	}
	err := r.SendToParent(&cosip.Response{agg})
	if err != nil {
		log.Error(err)
	}
}

// sig computes the signature as a slice of byte equal to:
// AggCommit || AggResponse
// Such  signature can be verified using `VerifySignature`.
func (r *randhoundCo) sig(aggResponse abstract.Scalar) {
	buff := new(bytes.Buffer)
	if _, err := r.aggCommit.MarshalTo(buff); err != nil {
		log.Error(err)
		return
	}
	if _, err := aggResponse.MarshalTo(buff); err != nil {
		log.Error(err)
		return
	}
	r.signature = buff.Bytes()
	if r.signatureHook != nil {
		r.signatureHook(r.signature)
	}
}

type SignatureHook func(sig []byte)

func (r *randhoundCo) RegisterSignatureHook(fn SignatureHook) {
	r.signatureHook = fn
}

func VerifySignature(suite abstract.Suite, aggPublic abstract.Point, msg, sig []byte) error {
	buffer := bytes.NewBuffer(sig)
	aggCommit := suite.Point()
	if _, err := aggCommit.UnmarshalFrom(buffer); err != nil {
		return err
	}

	aggResponse := suite.Scalar()
	if _, err := aggResponse.UnmarshalFrom(buffer); err != nil {
		return err
	}

	// left: g^r
	left := suite.Point().Mul(nil, aggResponse)

	// right: aggCommit + challenge * aggPublic
	// challenge: H(aggCommit || aggPublic || msg)
	hash := suite.Hash()
	if _, err := aggCommit.MarshalTo(hash); err != nil {
		return err
	}
	if _, err := aggPublic.MarshalTo(hash); err != nil {
		return err
	}
	hash.Write(msg)
	challenge := suite.Scalar().SetBytes(hash.Sum(nil))

	right := suite.Point().Mul(aggPublic, challenge)
	right = right.Add(right, aggCommit)

	if !right.Equal(left) {
		return errors.New("Signature re-created are not equal")
	}
	return nil
}
